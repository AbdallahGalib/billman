import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';

declare let self: ServiceWorkerGlobalScope;

// Precache all the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Clean up any previous precache
cleanupOutdatedCaches();

// Take control of all pages under this SW's scope immediately,
// instead of waiting for reload/navigation
self.skipWaiting();
clientsClaim();

// Cache strategies for different types of requests
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
);

// Cache the underlying font files with a cache-first strategy for 1 year
registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      {
        cacheKeyWillBeUsed: async ({ request }) => {
          return `${request.url}?v=1`;
        },
      },
    ],
  })
);

// Cache images with a cache-first strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      {
        cacheKeyWillBeUsed: async ({ request }) => {
          return request.url;
        },
      },
    ],
  })
);

// Cache API requests with a network-first strategy
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 3,
    plugins: [
      {
        cacheKeyWillBeUsed: async ({ request }) => {
          return request.url;
        },
      },
    ],
  })
);

// Cache Supabase requests with a network-first strategy
registerRoute(
  ({ url }) => url.hostname.includes('supabase'),
  new NetworkFirst({
    cacheName: 'supabase-cache',
    networkTimeoutSeconds: 5,
  })
);

// Handle offline fallback
import { setCatchHandler } from 'workbox-routing';

setCatchHandler(({ event }) => {
  // Return a generic offline page for navigation requests
  if (event.request.destination === 'document') {
    return caches.match('/offline.html');
  }

  // For other requests, return a generic error response
  return Response.error();
});

// Background sync for offline transactions
import { BackgroundSync } from 'workbox-background-sync';

const bgSync = new BackgroundSync('transaction-sync', {
  maxRetentionTime: 24 * 60, // Retry for max of 24 Hours (specified in minutes)
});

// Listen for sync events
self.addEventListener('sync', (event) => {
  if (event.tag === 'transaction-sync') {
    event.waitUntil(syncTransactions());
  }
});

async function syncTransactions() {
  try {
    // Get pending transactions from IndexedDB
    const pendingTransactions = await getPendingTransactions();
    
    if (pendingTransactions.length === 0) {
      return;
    }

    // Try to sync each transaction
    for (const transaction of pendingTransactions) {
      try {
        await syncTransaction(transaction);
        await removePendingTransaction(transaction.id);
      } catch (error) {
        console.error('Failed to sync transaction:', error);
      }
    }
  } catch (error) {
    console.error('Background sync failed:', error);
  }
}

async function getPendingTransactions() {
  // This would integrate with your IndexedDB implementation
  // For now, return empty array
  return [];
}

async function syncTransaction(transaction: any) {
  // This would make the actual API call to Supabase
  // Implementation depends on your sync strategy
  console.log('Syncing transaction:', transaction);
}

async function removePendingTransaction(id: string) {
  // Remove the transaction from the pending queue
  console.log('Removing pending transaction:', id);
}

// Handle push notifications (if needed in the future)
self.addEventListener('push', (event) => {
  if (!event.data) return;

  const data = event.data.json();
  const options = {
    body: data.body,
    icon: '/icon-192x192.png',
    badge: '/icon-192x192.png',
    data: data.data,
    actions: [
      {
        action: 'view',
        title: 'View',
        icon: '/icon-192x192.png'
      },
      {
        action: 'dismiss',
        title: 'Dismiss'
      }
    ]
  };

  event.waitUntil(
    self.registration.showNotification(data.title, options)
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  if (event.action === 'view') {
    event.waitUntil(
      self.clients.openWindow('/')
    );
  }
});

// Handle app installation
self.addEventListener('appinstalled', (event) => {
  console.log('PWA was installed');
});

// Handle app updates
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Periodic background sync (if supported)
self.addEventListener('periodicsync', (event) => {
  if (event.tag === 'transaction-cleanup') {
    event.waitUntil(cleanupOldTransactions());
  }
});

async function cleanupOldTransactions() {
  // Clean up old cached transactions
  console.log('Cleaning up old transactions');
}